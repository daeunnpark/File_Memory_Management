

	int status;
	printf("BEFORE everything\n");

	pid_t pid1= getpid();


	int j; 

	pid1 = fork();
	//	printf(" pid: %d\n ", getpid());

	if(pid1==0){ // child
		printf("child!\n");
	//	exit(0);
	} else { // parent

		printf("thread!\n");
		pthread_t tid1, tid2;

		//add to the list at first empty spot

		for(j=0; j<10; j++){	
			if(pidList[j]==0){
				pidList[j] = pid1;
				count++;
				break;
			}
		}

		printf("BEFORE THREADS\n");
		for(int k=0; k<10; k++){
			printf("pid at %d : %d\n",k+1, pidList[k]);
		}		

		if(reap_thread_flag==0){
			pthread_create(&tid1, NULL, cse320_reap_thread, &pidList);  
			printf("the main thread continues with its execution\n"); 		
			reap_thread_flag=1;
		}

		printf("rrrr%d\n", count);
		if(count ==0){
			printf("gggg\n");
			pthread_join(tid1, NULL); 
			printf("the main thread finished\n"); 
		}


	}


p = strtok (NULL, " ");  

	//	char    str[]= "ls -l";
		char ** res  = NULL;
		char *  p    = strtok (command, " ");
p = strtok (NULL, " ");  	
	int n_spaces = 0, i;


		/* split string and append tokens to 'res' */

		while (p) {
			res = realloc (res, sizeof (char*) * ++n_spaces);

			if (res == NULL)
				exit (-1); /* memory allocation failed */

			res[n_spaces-1] = p;

			p = strtok (NULL, " ");
		}

		/* realloc one extra element for the last NULL */

		res = realloc (res, sizeof (char*) * (n_spaces+1));
		res[n_spaces] = 0;

		/* print the result */

		for (i = 0; i < (n_spaces+1); ++i)
			printf ("res[%d] = %s\n", i, res[i]);

		/* free the memory allocated */

		//free (res);

		for (int o = 0; o < 2; ++o){
				printf ("11args[%d] = %s\n", o, args[o]);
				printf("after\n");
			}


